:t in GHCi returns the expression type.

: cons operator
1:[2,3] => [1,2,3]

++ combine lists
[1,2] ++ [3,4] => [1,2,3,4]
"abc" ++ "def" => "abcdef"

!! get an element out of a list by index
"Hello" !! 1 => "e"

Eq   => typeclass for types that support equality testing.
Ord  => typeclass for types that have an ordering.
Show => presents a value whose type is a member of Show and presents it as a string.
        show 5 = "5" :: String
Read => takes a string and returns a type which is a member of Read. You must tell the compiler what to do.
        read "10" + 2 = 12
        (read "5" :: Double) = 5.0
Enum => typeclass for sequentially ordered types. It also has defined successors (succ) and predecessors (pred).
Num => typeclass for things that act like numbers.
Floating, Integral

`let` bindings are expressions themselves. You can put them almost anywhere and
use them to create functions in a local scope. You can pattern match them
(let (a,b,c) = (1,2,3) in a + b + c) * 100 => 600

Case expressions are expressions, doh!
case expr of pattern -> result
             pattern -> result
             pattern -> result

